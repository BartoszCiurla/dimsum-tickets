{"version":3,"sources":["utils/tree.util.js"],"names":["evalParent","hash","selectedItems","acc","parentId","mixed","parent","parents","push","selectedChilds","filter","child","concat","children","length","newMixed","items","selectedItemsMapper","treeViewRef","allItems","filterFn","selectedIds","get","Object","keys","reduce","id","item"],"mappings":"iGAAA,2HAgBaA,EAAa,SAAbA,EAAc,GAMpB,IALLC,EAKI,EALJA,KACAC,EAII,EAJJA,cACAC,EAGI,EAHJA,IACAC,EAEI,EAFJA,SAEI,IADJC,aACI,SACEC,EAASL,EAAKG,GACpBD,EAAII,QAAQC,KAAKF,GACjB,IAAIG,EAAiBP,EAAcQ,QACjC,SAACC,GAAD,OAAWA,EAAML,SAAWF,KAK9B,GAHAK,EAAiBA,EAAeG,OAC9BT,EAAII,QAAQG,QAAO,SAACC,GAAD,OAAWA,EAAML,SAAWF,MAE7CE,EAAOO,SAASC,OAAS,EAAG,CAC9B,IAAIC,EAAWV,EAOf,GANIC,EAAOO,SAASC,SAAWL,EAAeK,QAAWT,GAGvDF,EAAIa,MAAMZ,GAAY,QACtBW,GAAW,GAHXZ,EAAIa,MAAMZ,IAAY,EAKpBE,EAAOA,SAAWH,EAAIa,MAAMV,EAAOA,QACrC,OAAON,EAAW,CAChBC,OACAC,gBACAC,MACAC,SAAUE,EAAOA,OACjBD,MAAOU,IAIb,OAAOZ,GAaIc,EAAsB,SAACC,EAAaC,GAAd,OAA2B,WAGxD,IAFJC,EAEG,uDAFQ,kBAAM,GACjBC,EACG,uDADWC,IAAIJ,EAAa,0BAA2B,IAGpDhB,EAAgBqB,OAAOC,KAAKH,GAAaI,QAC7C,SAACT,EAAOU,GACN,GAAW,QAAPA,IAAiBL,EAAYK,GAAK,OAAOV,EAC7C,IAAMW,EAAOR,EAASO,GACtB,OAAKC,GAASP,EAASO,IACvBX,EAAMR,KAAKmB,GACJX,GAF8BA,IAIvC,IAEF,OAAOd","file":"static/js/50.b2acd8c2.chunk.js","sourcesContent":["import get from 'lodash/get';\n\n// Meant to hold any reusable functionality related to dimsum's tree view component\n\n/**\n * Verifies if the parent element has selected children\n *\n * @param {object} param all params\n * @param {object} param.hash { [id]: ... } all tree elements in a hash object\n * @param {Array} param.selectedItems The selected items, must include parent key { parent, ... }\n * @param {object} param.acc { items (object), parents (array) }\n * items: all selected elements\n * @param {string} param.parentId The parent identifier\n * @param {boolean} param.mixed Allows marking the selection as indeterminate\n * @returns {object} Same *acc* with the correct parent selected state { items (object), parents (array) }\n */\nexport const evalParent = ({\n  hash,\n  selectedItems,\n  acc,\n  parentId,\n  mixed = false,\n}) => {\n  const parent = hash[parentId];\n  acc.parents.push(parent);\n  let selectedChilds = selectedItems.filter(\n    (child) => child.parent === parentId,\n  );\n  selectedChilds = selectedChilds.concat(\n    acc.parents.filter((child) => child.parent === parentId),\n  );\n  if (parent.children.length > 0) {\n    let newMixed = mixed;\n    if (parent.children.length === selectedChilds.length && !mixed) {\n      acc.items[parentId] = true; // mark as selected\n    } else {\n      acc.items[parentId] = 'mixed';\n      newMixed = true; // mark as indterminate\n    }\n    if (parent.parent && !acc.items[parent.parent]) {\n      return evalParent({\n        hash,\n        selectedItems,\n        acc,\n        parentId: parent.parent,\n        mixed: newMixed,\n      });\n    }\n  }\n  return acc;\n};\n\n/**\n * HOF that returns a mapper for selected items ids from TreeView's state.\n * Can provide a filter for each of the selected elements\n *\n * @example <caption> Returned Function Usage </caption>\n * getSelectedItems((item) => item.type === 'task'); // only getting task elements\n * @param {*} treeViewRef The tree view component's reference\n * @param {*} allItems All tree records/items in a key hash\n * @returns {Function} The getSelectedItems function that receives an optional filter function\n */\nexport const selectedItemsMapper = (treeViewRef, allItems) => (\n  filterFn = () => true,\n  selectedIds = get(treeViewRef, 'current.state.selection', {}), // check this object, could be some timing issues with the selection\n) => {\n  // Timeout is used to get new state from the treeview\n  const selectedItems = Object.keys(selectedIds).reduce(\n    (items, id) => {\n      if (id === 'all' || !selectedIds[id]) return items;\n      const item = allItems[id];\n      if (!item || !filterFn(item)) return items;\n      items.push(item);\n      return items;\n    },\n    [],\n  );\n  return selectedItems;\n};\n"],"sourceRoot":""}